{
  "version": 3,
  "sources": ["../../../../node_modules/@formily/json-schema/src/shared.ts", "../../../../node_modules/@formily/json-schema/src/compiler.ts", "../../../../node_modules/@formily/json-schema/src/transformer.ts", "../../../../node_modules/@formily/json-schema/src/patches.ts", "../../../../node_modules/@formily/json-schema/src/polyfills/SPECIFICATION_1_0.ts", "../../../../node_modules/@formily/json-schema/src/schema.ts", "../../../../node_modules/@formily/vue/node_modules/vue-demi/lib/index.esm.js", "../../../../node_modules/@formily/vue/src/shared/context.ts", "../../../../node_modules/@formily/vue/src/hooks/useAttach.ts", "../../../../node_modules/@formily/vue/src/hooks/useInjectionCleaner.ts", "../../../../node_modules/@formily/vue/node_modules/vue-frag/dist/frag.esm.js", "../../../../node_modules/@formily/vue/src/shared/fragment.ts", "../../../../node_modules/@formily/vue/src/utils/formatVNodeData.ts", "../../../../node_modules/@formily/vue/src/shared/h.ts", "../../../../node_modules/@formily/vue/src/components/FormProvider.ts", "../../../../node_modules/@formily/vue/src/hooks/useForm.ts", "../../../../node_modules/@formily/vue/src/hooks/useField.ts", "../../../../node_modules/@formily/vue/src/hooks/useFormEffects.ts", "../../../../node_modules/@formily/vue/src/hooks/useFieldSchema.ts", "../../../../node_modules/@formily/vue/src/hooks/useParentForm.ts", "../../../../node_modules/@formily/vue/src/components/FormConsumer.ts", "../../../../node_modules/@formily/vue/src/shared/connect.ts", "../../../../node_modules/@formily/vue/src/shared/createForm.ts", "../../../../node_modules/@formily/vue/src/components/ReactiveField.ts", "../../../../node_modules/@formily/vue/src/utils/getRawComponent.ts", "../../../../node_modules/@formily/vue/src/utils/getFieldProps.ts", "../../../../node_modules/@formily/vue/src/components/ArrayField.ts", "../../../../node_modules/@formily/vue/src/components/ObjectField.ts", "../../../../node_modules/@formily/vue/src/components/VoidField.ts", "../../../../node_modules/@formily/vue/src/components/Field.ts", "../../../../node_modules/@formily/vue/src/components/RecursionField.ts", "../../../../node_modules/@formily/vue/src/utils/resolveSchemaProps.ts", "../../../../node_modules/@formily/vue/src/components/SchemaField.ts", "../../../../node_modules/@formily/vue/src/components/ExpressionScope.ts", "../../../../node_modules/@formily/vue/src/vue2-components.ts"],
  "sourcesContent": ["import { isFn, each, isPlainObj, isArr, toArr, FormPath } from '@formily/shared'\nimport { isObservable, untracked } from '@formily/reactive'\nimport { Schema } from './schema'\nimport { ISchema } from './types'\n\nconst REVA_ACTIONS_KEY = Symbol.for('__REVA_ACTIONS')\n\nexport const SchemaNestedMap = {\n  parent: true,\n  root: true,\n  properties: true,\n  patternProperties: true,\n  additionalProperties: true,\n  items: true,\n  additionalItems: true,\n  'x-linkages': true,\n  'x-reactions': true,\n}\n\nexport const SchemaStateMap = {\n  title: 'title',\n  description: 'description',\n  default: 'initialValue',\n  enum: 'dataSource',\n  readOnly: 'readOnly',\n  writeOnly: 'editable',\n  'x-content': 'content',\n  'x-data': 'data',\n  'x-value': 'value',\n  'x-editable': 'editable',\n  'x-disabled': 'disabled',\n  'x-read-pretty': 'readPretty',\n  'x-read-only': 'readOnly',\n  'x-visible': 'visible',\n  'x-hidden': 'hidden',\n  'x-display': 'display',\n  'x-pattern': 'pattern',\n  'x-validator': 'validator',\n  'x-decorator': 'decoratorType',\n  'x-component': 'componentType',\n  'x-decorator-props': 'decoratorProps',\n  'x-component-props': 'componentProps',\n}\n\nexport const SchemaValidatorMap = {\n  required: true,\n  format: true,\n  maxItems: true,\n  minItems: true,\n  maxLength: true,\n  minLength: true,\n  maximum: true,\n  minimum: true,\n  exclusiveMaximum: true,\n  exclusiveMinimum: true,\n  pattern: true,\n  const: true,\n  multipleOf: true,\n  maxProperties: true,\n  minProperties: true,\n  uniqueItems: true,\n}\n\nexport const SchemaNormalKeys = Object.keys(SchemaStateMap)\n\nexport const SchemaValidatorKeys = Object.keys(SchemaValidatorMap)\n\nexport const hasOwnProperty = Object.prototype.hasOwnProperty\n\nexport const traverse = (\n  target: any,\n  visitor: (value: any, path: Array<string | number>) => void\n) => {\n  const seenObjects = []\n  const root = target\n  const traverse = (target: any, path = []) => {\n    if (isPlainObj(target)) {\n      const seenIndex = seenObjects.indexOf(target)\n      if (seenIndex > -1) {\n        return\n      }\n      const addIndex = seenObjects.length\n      seenObjects.push(target)\n      if (isNoNeedCompileObject(target) && root !== target) {\n        visitor(target, path)\n        return\n      }\n      each(target, (value, key) => {\n        traverse(value, path.concat(key))\n      })\n      seenObjects.splice(addIndex, 1)\n    } else {\n      visitor(target, path)\n    }\n  }\n  traverse(target)\n}\n\nexport const traverseSchema = (\n  schema: ISchema,\n  visitor: (value: any, path: any[]) => void\n) => {\n  if (schema['x-validator'] !== undefined) {\n    visitor(schema['x-validator'], ['x-validator'])\n  }\n  const seenObjects = []\n  const root = schema\n  const traverse = (target: any, path = []) => {\n    if (\n      path[0] === 'x-validator' ||\n      path[0] === 'version' ||\n      path[0] === '_isJSONSchemaObject'\n    )\n      return\n    if (String(path[0]).indexOf('x-') == -1 && isFn(target)) return\n    if (SchemaNestedMap[path[0]]) return\n    if (isPlainObj(target)) {\n      if (path[0] === 'default' || path[0] === 'x-value') {\n        visitor(target, path)\n        return\n      }\n      const seenIndex = seenObjects.indexOf(target)\n      if (seenIndex > -1) {\n        return\n      }\n      const addIndex = seenObjects.length\n      seenObjects.push(target)\n      if (isNoNeedCompileObject(target) && root !== target) {\n        visitor(target, path)\n        return\n      }\n      each(target, (value, key) => {\n        traverse(value, path.concat(key))\n      })\n      seenObjects.splice(addIndex, 1)\n    } else {\n      visitor(target, path)\n    }\n  }\n  traverse(schema)\n}\n\nexport const isNoNeedCompileObject = (source: any) => {\n  if ('$$typeof' in source && '_owner' in source) {\n    return true\n  }\n  if (source['_isAMomentObject']) {\n    return true\n  }\n  if (Schema.isSchemaInstance(source)) {\n    return true\n  }\n  if (source[REVA_ACTIONS_KEY]) {\n    return true\n  }\n  if (isFn(source['toJS'])) {\n    return true\n  }\n  if (isFn(source['toJSON'])) {\n    return true\n  }\n  if (isObservable(source)) {\n    return true\n  }\n  return false\n}\n\nexport const createDataSource = (source: any[]) => {\n  return toArr(source).map((item) => {\n    if (typeof item === 'object') {\n      return item\n    } else {\n      return {\n        label: item,\n        value: item,\n      }\n    }\n  })\n}\n\nexport const patchStateFormSchema = (\n  targetState: any,\n  pattern: any[],\n  compiled: any\n) => {\n  untracked(() => {\n    const path = FormPath.parse(pattern)\n    const segments = path.segments\n    const key = segments[0]\n    const isEnum = key === 'enum' && isArr(compiled)\n    const schemaMapKey = SchemaStateMap[key]\n    if (schemaMapKey) {\n      FormPath.setIn(\n        targetState,\n        [schemaMapKey].concat(segments.slice(1)),\n        isEnum ? createDataSource(compiled) : compiled\n      )\n    } else {\n      const isValidatorKey = SchemaValidatorMap[key]\n      if (isValidatorKey) {\n        targetState['setValidatorRule']?.(key, compiled)\n      }\n    }\n  })\n}\n", "import {\n  isArr,\n  isFn,\n  isPlainObj,\n  isStr,\n  reduce,\n  FormPath,\n} from '@formily/shared'\nimport { IGeneralFieldState } from '@formily/core'\nimport { untracked, hasCollected } from '@formily/reactive'\nimport {\n  traverse,\n  traverseSchema,\n  isNoNeedCompileObject,\n  hasOwnProperty,\n  patchStateFormSchema,\n} from './shared'\nimport { ISchema } from './types'\n\nconst ExpRE = /^\\s*\\{\\{([\\s\\S]*)\\}\\}\\s*$/\nconst Registry = {\n  silent: false,\n  compile(expression: string, scope = {}) {\n    if (Registry.silent) {\n      try {\n        return new Function('$root', `with($root) { return (${expression}); }`)(\n          scope\n        )\n      } catch {}\n    } else {\n      return new Function('$root', `with($root) { return (${expression}); }`)(\n        scope\n      )\n    }\n  },\n}\n\nexport const silent = (value = true) => {\n  Registry.silent = !!value\n}\n\nexport const registerCompiler = (\n  compiler: (expression: string, scope: any) => any\n) => {\n  if (isFn(compiler)) {\n    Registry.compile = compiler\n  }\n}\n\nexport const shallowCompile = <Source = any, Scope = any>(\n  source: Source,\n  scope?: Scope\n) => {\n  if (isStr(source)) {\n    const matched = source.match(ExpRE)\n    if (!matched) return source\n    return Registry.compile(matched[1], scope)\n  }\n  return source\n}\n\nexport const compile = <Source = any, Scope = any>(\n  source: Source,\n  scope?: Scope\n): any => {\n  const seenObjects = []\n  const compile = (source: any) => {\n    if (isStr(source)) {\n      return shallowCompile(source, scope)\n    } else if (isArr(source)) {\n      return source.map((value: any) => compile(value))\n    } else if (isPlainObj(source)) {\n      if (isNoNeedCompileObject(source)) return source\n      const seenIndex = seenObjects.indexOf(source)\n      if (seenIndex > -1) {\n        return source\n      }\n      const addIndex = seenObjects.length\n      seenObjects.push(source)\n      const results = reduce(\n        source,\n        (buf, value, key) => {\n          buf[key] = compile(value)\n          return buf\n        },\n        {}\n      )\n      seenObjects.splice(addIndex, 1)\n      return results\n    }\n    return source\n  }\n  return compile(source)\n}\n\nexport const patchCompile = (\n  targetState: IGeneralFieldState,\n  sourceState: any,\n  scope: any\n) => {\n  traverse(sourceState, (value, pattern) => {\n    const path = FormPath.parse(pattern)\n    const compiled = compile(value, scope)\n    const key = path.segments[0]\n    if (compiled === undefined) return\n    if (hasOwnProperty.call(targetState, key)) {\n      untracked(() => FormPath.setIn(targetState, path, compiled))\n    }\n  })\n}\n\nexport const patchSchemaCompile = (\n  targetState: IGeneralFieldState,\n  sourceSchema: ISchema,\n  scope: any,\n  demand = false\n) => {\n  traverseSchema(sourceSchema, (value, path) => {\n    let compiled = value\n    let collected = hasCollected(() => {\n      compiled = compile(value, scope)\n    })\n    if (compiled === undefined) return\n    if (demand) {\n      if (collected || !targetState.initialized) {\n        patchStateFormSchema(targetState, path, compiled)\n      }\n    } else {\n      patchStateFormSchema(targetState, path, compiled)\n    }\n  })\n}\n", "import { untracked, autorun, observable } from '@formily/reactive'\nimport {\n  isArr,\n  isStr,\n  toArr,\n  each,\n  isFn,\n  isPlainObj,\n  reduce,\n} from '@formily/shared'\nimport { Schema } from './schema'\nimport {\n  ISchema,\n  ISchemaTransformerOptions,\n  IFieldStateSetterOptions,\n  SchemaReaction,\n} from './types'\nimport {\n  onFieldInit,\n  onFieldMount,\n  onFieldUnmount,\n  onFieldValueChange,\n  onFieldInputValueChange,\n  onFieldInitialValueChange,\n  onFieldValidateStart,\n  onFieldValidateEnd,\n  onFieldValidateFailed,\n  onFieldValidateSuccess,\n  IFieldFactoryProps,\n  Field,\n} from '@formily/core'\nimport { patchCompile, patchSchemaCompile, shallowCompile } from './compiler'\n\nconst FieldEffects = {\n  onFieldInit,\n  onFieldMount,\n  onFieldUnmount,\n  onFieldValueChange,\n  onFieldInputValueChange,\n  onFieldInitialValueChange,\n  onFieldValidateStart,\n  onFieldValidateEnd,\n  onFieldValidateFailed,\n  onFieldValidateSuccess,\n}\n\nconst DefaultFieldEffects = ['onFieldInit', 'onFieldValueChange']\n\nconst getDependencyValue = (\n  field: Field,\n  pattern: string,\n  property?: string\n) => {\n  const [target, path] = String(pattern).split(/\\s*#\\s*/)\n  return field.query(target).getIn(path || property || 'value')\n}\n\nconst getDependencies = (\n  field: Field,\n  dependencies:\n    | Array<string | { name?: string; source?: string; property?: string }>\n    | object\n) => {\n  if (isArr(dependencies)) {\n    const results = []\n    dependencies.forEach((pattern) => {\n      if (isStr(pattern)) {\n        results.push(getDependencyValue(field, pattern))\n      } else if (isPlainObj(pattern)) {\n        if (pattern.name && pattern.source) {\n          results[pattern.name] = getDependencyValue(\n            field,\n            pattern.source,\n            pattern.property\n          )\n        }\n      }\n    })\n    return results\n  } else if (isPlainObj(dependencies)) {\n    return reduce(\n      dependencies,\n      (buf, pattern, key) => {\n        buf[key] = getDependencyValue(field, pattern)\n        return buf\n      },\n      {}\n    )\n  }\n  return []\n}\n\nconst setSchemaFieldState = (\n  options: IFieldStateSetterOptions,\n  demand = false\n) => {\n  const { request, target, runner, field, scope } = options || {}\n  if (!request) return\n  if (target) {\n    if (request.state) {\n      field.form.setFieldState(target, (state) =>\n        patchCompile(state, request.state, {\n          ...scope,\n          $target: state,\n        })\n      )\n    }\n    if (request.schema) {\n      field.form.setFieldState(target, (state) =>\n        patchSchemaCompile(\n          state,\n          request.schema,\n          {\n            ...scope,\n            $target: state,\n          },\n          demand\n        )\n      )\n    }\n    if (isStr(runner) && runner) {\n      field.form.setFieldState(target, (state) => {\n        shallowCompile(`{{function(){${runner}}}}`, {\n          ...scope,\n          $target: state,\n        })()\n      })\n    }\n  } else {\n    if (request.state) {\n      field.setState((state) => patchCompile(state, request.state, scope))\n    }\n    if (request.schema) {\n      field.setState((state) =>\n        patchSchemaCompile(state, request.schema, scope, demand)\n      )\n    }\n    if (isStr(runner) && runner) {\n      shallowCompile(`{{function(){${runner}}}}`, scope)()\n    }\n  }\n}\n\nconst getBaseScope = (\n  field: Field,\n  options: ISchemaTransformerOptions = {}\n) => {\n  const $observable = (target: any, deps?: any[]) =>\n    autorun.memo(() => observable(target), deps)\n  const $props = (props: any) => field.setComponentProps(props)\n  const $effect = autorun.effect\n  const $memo = autorun.memo\n  const $self = field\n  const $form = field.form\n  const $values = field.form.values\n  return {\n    ...options.scope,\n    $form,\n    $self,\n    $observable,\n    $effect,\n    $memo,\n    $props,\n    $values,\n  }\n}\n\nconst getBaseReactions =\n  (schema: ISchema, options: ISchemaTransformerOptions) => (field: Field) => {\n    setSchemaFieldState(\n      {\n        field,\n        request: { schema },\n        scope: getBaseScope(field, options),\n      },\n      true\n    )\n  }\n\nconst getUserReactions = (\n  schema: ISchema,\n  options: ISchemaTransformerOptions\n) => {\n  const reactions: SchemaReaction[] = toArr(schema['x-reactions'])\n  return reactions.map((unCompiled) => {\n    return (field: Field) => {\n      const baseScope = getBaseScope(field, options)\n      const reaction = shallowCompile(unCompiled, baseScope)\n      if (!reaction) return\n      if (isFn(reaction)) {\n        return reaction(field, baseScope)\n      }\n      const { when, fulfill, otherwise, target, effects } = reaction\n      const run = () => {\n        const $deps = getDependencies(field, reaction.dependencies)\n        const $dependencies = $deps\n        const scope = {\n          ...baseScope,\n          $target: null,\n          $deps,\n          $dependencies,\n        }\n        const compiledWhen = shallowCompile(when, scope)\n        const condition = when ? compiledWhen : true\n        const request = condition ? fulfill : otherwise\n        const runner = condition ? fulfill?.run : otherwise?.run\n        setSchemaFieldState({\n          field,\n          target,\n          request,\n          runner,\n          scope,\n        })\n      }\n\n      if (target) {\n        reaction.effects = effects?.length ? effects : DefaultFieldEffects\n      }\n      if (reaction.effects) {\n        autorun.memo(() => {\n          untracked(() => {\n            each(reaction.effects, (type) => {\n              if (FieldEffects[type]) {\n                FieldEffects[type](field.address, run)\n              }\n            })\n          })\n        }, [])\n      } else {\n        run()\n      }\n    }\n  })\n}\n\nexport const transformFieldProps = (\n  schema: Schema,\n  options: ISchemaTransformerOptions\n): IFieldFactoryProps<any, any> => {\n  return {\n    name: schema.name,\n    reactions: [getBaseReactions(schema, options)].concat(\n      getUserReactions(schema, options)\n    ),\n  }\n}\n", "import { isFn, isArr } from '@formily/shared'\nimport { SchemaPatch } from './types'\n\nconst patches: SchemaPatch[] = []\n\nconst polyfills: Record<string, SchemaPatch[]> = {}\n\nexport const reducePatches = (schema: any) => {\n  return patches.reduce(\n    (buf, patch) => {\n      return patch(buf)\n    },\n    { ...schema }\n  )\n}\n\nexport const registerPatches = (...args: SchemaPatch[]) => {\n  args.forEach((patch) => {\n    if (isFn(patch)) {\n      patches.push(patch)\n    }\n  })\n}\n\nexport const registerPolyfills = (version: string, patch: SchemaPatch) => {\n  if (version && isFn(patch)) {\n    polyfills[version] = polyfills[version] || []\n    polyfills[version].push(patch)\n  }\n}\n\nexport const enablePolyfills = (versions?: string[]) => {\n  if (isArr(versions)) {\n    versions.forEach((version) => {\n      if (isArr(polyfills[version])) {\n        polyfills[version].forEach((patch) => {\n          registerPatches(patch)\n        })\n      }\n    })\n  }\n}\n", "import { registerPolyfills } from '../patches'\nimport { toArr, isArr, isStr, lowerCase, isValid } from '@formily/shared'\nimport { ISchema } from '../types'\n\nconst VOID_COMPONENTS = [\n  'card',\n  'block',\n  'grid-col',\n  'grid-row',\n  'grid',\n  'layout',\n  'step',\n  'tab',\n  'text-box',\n]\n\nconst TYPE_DEFAULT_COMPONENTS = {}\n\nconst transformCondition = (condition: string) => {\n  if (isStr(condition)) {\n    return condition.replace(/\\$value/, '$self.value')\n  }\n}\n\nconst transformXLinkage = (linkages: any[]) => {\n  if (isArr(linkages)) {\n    return linkages.reduce((buf, item) => {\n      if (!item) return buf\n      if (item.type === 'value:visible') {\n        return buf.concat({\n          target: item.target,\n          when: transformCondition(item.condition),\n          fulfill: {\n            state: {\n              visible: true,\n            },\n          },\n          otherwise: {\n            state: {\n              visible: false,\n            },\n          },\n        })\n      } else if (item.type === 'value:schema') {\n        return buf.concat({\n          target: item.target,\n          when: transformCondition(item.condition),\n          fulfill: {\n            schema: SpecificationV1Polyfill({ version: '1.0', ...item.schema }),\n          },\n          otherwise: {\n            schema: SpecificationV1Polyfill({\n              version: '1.0',\n              ...item.otherwise,\n            }),\n          },\n        })\n      } else if (item.type === 'value:state') {\n        return buf.concat({\n          target: item.target,\n          when: transformCondition(item.condition),\n          fulfill: {\n            state: item.state,\n          },\n          otherwise: {\n            state: item.otherwise,\n          },\n        })\n      }\n    }, [])\n  }\n  return []\n}\n\nconst SpecificationV1Polyfill = (schema: ISchema) => {\n  if (isValid(schema['editable'])) {\n    schema['x-editable'] = schema['x-editable'] || schema['editable']\n    delete schema['editable']\n  }\n  if (isValid(schema['visible'])) {\n    schema['x-visible'] = schema['x-visible'] || schema['visible']\n    delete schema['visible']\n  }\n  if (isValid(schema['display'])) {\n    schema['x-display'] =\n      schema['x-display'] || (schema['display'] ? 'visible' : 'hidden')\n    delete schema['display']\n  }\n  if (isValid(schema['x-props'])) {\n    schema['x-decorator-props'] =\n      schema['x-decorator-props'] || schema['x-props']\n    delete schema['display']\n  }\n  if (schema['x-linkages']) {\n    schema['x-reactions'] = toArr(schema['x-reactions']).concat(\n      transformXLinkage(schema['x-linkages'])\n    )\n    delete schema['x-linkages']\n  }\n  if (schema['x-component']) {\n    if (\n      VOID_COMPONENTS.some(\n        (component) => lowerCase(component) === lowerCase(schema['x-component'])\n      )\n    ) {\n      schema['type'] = 'void'\n    }\n  } else {\n    if (TYPE_DEFAULT_COMPONENTS[schema['type']]) {\n      schema['x-component'] = TYPE_DEFAULT_COMPONENTS[schema['type']]\n    }\n  }\n  if (\n    !schema['x-decorator'] &&\n    schema['type'] !== 'void' &&\n    schema['type'] !== 'object'\n  ) {\n    schema['x-decorator'] = schema['x-decorator'] || 'FormItem'\n  }\n  if (schema['x-rules']) {\n    schema['x-validator'] = []\n      .concat(schema['x-validator'] || [])\n      .concat(schema['x-rules'])\n  }\n  return schema\n}\n\nregisterPolyfills('1.0', SpecificationV1Polyfill)\n\nexport const registerVoidComponents = (components: string[]) => {\n  VOID_COMPONENTS.push(...components)\n}\n\nexport const registerTypeDefaultComponents = (maps: Record<string, string>) => {\n  Object.assign(TYPE_DEFAULT_COMPONENTS, maps)\n}\n", "import {\n  ISchema,\n  SchemaEnum,\n  SchemaProperties,\n  SchemaReaction,\n  SchemaTypes,\n  SchemaKey,\n  ISchemaTransformerOptions,\n} from './types'\nimport { IFieldFactoryProps } from '@formily/core'\nimport { map, each, isFn, instOf, FormPath, isStr } from '@formily/shared'\nimport { compile, silent, shallowCompile, registerCompiler } from './compiler'\nimport { transformFieldProps } from './transformer'\nimport {\n  reducePatches,\n  registerPatches,\n  registerPolyfills,\n  enablePolyfills,\n} from './patches'\nimport {\n  registerVoidComponents,\n  registerTypeDefaultComponents,\n} from './polyfills'\nimport { SchemaNestedMap } from './shared'\n\nexport class Schema<\n  Decorator = any,\n  Component = any,\n  DecoratorProps = any,\n  ComponentProps = any,\n  Pattern = any,\n  Display = any,\n  Validator = any,\n  Message = any,\n  ReactionField = any\n> implements ISchema\n{\n  parent?: Schema\n  root?: Schema\n  name?: SchemaKey\n  title?: Message\n  description?: Message\n  default?: any\n  readOnly?: boolean\n  writeOnly?: boolean\n  type?: SchemaTypes\n  enum?: SchemaEnum<Message>\n  const?: any\n  multipleOf?: number\n  maximum?: number\n  exclusiveMaximum?: number\n  minimum?: number\n  exclusiveMinimum?: number\n  maxLength?: number\n  minLength?: number\n  pattern?: string | RegExp\n  maxItems?: number\n  minItems?: number\n  uniqueItems?: boolean\n  maxProperties?: number\n  minProperties?: number\n  required?: string[] | boolean | string\n  format?: string\n  /** nested json schema spec **/\n  definitions?: Record<\n    string,\n    Schema<\n      Decorator,\n      Component,\n      DecoratorProps,\n      ComponentProps,\n      Pattern,\n      Display,\n      Validator,\n      Message\n    >\n  >\n  properties?: Record<\n    string,\n    Schema<\n      Decorator,\n      Component,\n      DecoratorProps,\n      ComponentProps,\n      Pattern,\n      Display,\n      Validator,\n      Message\n    >\n  >\n  items?:\n    | Schema<\n        Decorator,\n        Component,\n        DecoratorProps,\n        ComponentProps,\n        Pattern,\n        Display,\n        Validator,\n        Message\n      >\n    | Schema<\n        Decorator,\n        Component,\n        DecoratorProps,\n        ComponentProps,\n        Pattern,\n        Display,\n        Validator,\n        Message\n      >[]\n  additionalItems?: Schema<\n    Decorator,\n    Component,\n    DecoratorProps,\n    ComponentProps,\n    Pattern,\n    Display,\n    Validator,\n    Message\n  >\n  patternProperties?: Record<\n    string,\n    Schema<\n      Decorator,\n      Component,\n      DecoratorProps,\n      ComponentProps,\n      Pattern,\n      Display,\n      Validator,\n      Message\n    >\n  >\n  additionalProperties?: Schema<\n    Decorator,\n    Component,\n    DecoratorProps,\n    ComponentProps,\n    Pattern,\n    Display,\n    Validator,\n    Message\n  >;\n\n  //顺序描述\n  ['x-index']?: number;\n  //交互模式\n  ['x-pattern']?: Pattern;\n  //展示状态\n  ['x-display']?: Display;\n  //校验器\n  ['x-validator']?: Validator;\n  //装饰器\n  ['x-decorator']?: Decorator;\n  //装饰器属性\n  ['x-decorator-props']?: DecoratorProps;\n  //组件\n  ['x-component']?: Component;\n  //组件属性\n  ['x-component-props']?: ComponentProps;\n\n  ['x-reactions']?: SchemaReaction<ReactionField>[];\n\n  ['x-content']?: any;\n\n  ['x-data']?: any;\n\n  ['x-visible']?: boolean;\n\n  ['x-hidden']?: boolean;\n\n  ['x-disabled']?: boolean;\n\n  ['x-editable']?: boolean;\n\n  ['x-read-only']?: boolean;\n\n  ['x-read-pretty']?: boolean;\n\n  [key: `x-${string | number}` | symbol]: any\n\n  _isJSONSchemaObject = true\n\n  version = '2.0'\n\n  constructor(\n    json: ISchema<\n      Decorator,\n      Component,\n      DecoratorProps,\n      ComponentProps,\n      Pattern,\n      Display,\n      Validator,\n      Message\n    >,\n    parent?: Schema\n  ) {\n    if (parent) {\n      this.parent = parent\n      this.root = parent.root\n    } else {\n      this.root = this\n    }\n    return this.fromJSON(json)\n  }\n\n  addProperty = (\n    key: SchemaKey,\n    schema: ISchema<\n      Decorator,\n      Component,\n      DecoratorProps,\n      ComponentProps,\n      Pattern,\n      Display,\n      Validator,\n      Message\n    >\n  ) => {\n    this.properties = this.properties || {}\n    this.properties[key] = new Schema(schema, this)\n    this.properties[key].name = key\n    return this.properties[key]\n  }\n\n  removeProperty = (key: SchemaKey) => {\n    const schema = this.properties[key]\n    delete this.properties[key]\n    return schema\n  }\n\n  setProperties = (\n    properties: SchemaProperties<\n      Decorator,\n      Component,\n      DecoratorProps,\n      ComponentProps,\n      Pattern,\n      Display,\n      Validator,\n      Message\n    >\n  ) => {\n    for (const key in properties) {\n      this.addProperty(key, properties[key])\n    }\n    return this\n  }\n\n  addPatternProperty = (\n    key: SchemaKey,\n    schema: ISchema<\n      Decorator,\n      Component,\n      DecoratorProps,\n      ComponentProps,\n      Pattern,\n      Display,\n      Validator,\n      Message\n    >\n  ) => {\n    if (!schema) return\n    this.patternProperties = this.patternProperties || {}\n    this.patternProperties[key] = new Schema(schema, this)\n    this.patternProperties[key].name = key\n    return this.patternProperties[key]\n  }\n\n  removePatternProperty = (key: SchemaKey) => {\n    const schema = this.patternProperties[key]\n    delete this.patternProperties[key]\n    return schema\n  }\n\n  setPatternProperties = (\n    properties: SchemaProperties<\n      Decorator,\n      Component,\n      DecoratorProps,\n      ComponentProps,\n      Pattern,\n      Display,\n      Validator,\n      Message\n    >\n  ) => {\n    if (!properties) return this\n    for (const key in properties) {\n      this.addPatternProperty(key, properties[key])\n    }\n    return this\n  }\n\n  setAdditionalProperties = (\n    properties: ISchema<\n      Decorator,\n      Component,\n      DecoratorProps,\n      ComponentProps,\n      Pattern,\n      Display,\n      Validator,\n      Message\n    >\n  ) => {\n    if (!properties) return\n    this.additionalProperties = new Schema(properties)\n    return this.additionalProperties\n  }\n\n  setItems = (\n    schema:\n      | ISchema<\n          Decorator,\n          Component,\n          DecoratorProps,\n          ComponentProps,\n          Pattern,\n          Display,\n          Validator,\n          Message\n        >\n      | ISchema<\n          Decorator,\n          Component,\n          DecoratorProps,\n          ComponentProps,\n          Pattern,\n          Display,\n          Validator,\n          Message\n        >[]\n  ) => {\n    if (!schema) return\n    if (Array.isArray(schema)) {\n      this.items = schema.map((item) => new Schema(item, this))\n    } else {\n      this.items = new Schema(schema, this)\n    }\n    return this.items\n  }\n\n  setAdditionalItems = (\n    items: ISchema<\n      Decorator,\n      Component,\n      DecoratorProps,\n      ComponentProps,\n      Pattern,\n      Display,\n      Validator,\n      Message\n    >\n  ) => {\n    if (!items) return\n    this.additionalItems = new Schema(items, this)\n    return this.additionalItems\n  }\n\n  findDefinitions = (ref: string) => {\n    if (!ref || !this.root || !isStr(ref)) return\n    if (ref.indexOf('#/') !== 0) return\n    return FormPath.getIn(this.root, ref.substring(2).split('/'))\n  }\n\n  mapProperties = <T>(\n    callback?: (\n      schema: Schema<\n        Decorator,\n        Component,\n        DecoratorProps,\n        ComponentProps,\n        Pattern,\n        Display,\n        Validator,\n        Message\n      >,\n      key: SchemaKey,\n      index: number\n    ) => T\n  ): T[] => {\n    return Schema.getOrderProperties(this).map(({ schema, key }, index) => {\n      return callback(schema, key, index)\n    })\n  }\n\n  mapPatternProperties = <T>(\n    callback?: (\n      schema: Schema<\n        Decorator,\n        Component,\n        DecoratorProps,\n        ComponentProps,\n        Pattern,\n        Display,\n        Validator,\n        Message\n      >,\n      key: SchemaKey,\n      index: number\n    ) => T\n  ): T[] => {\n    return Schema.getOrderProperties(this, 'patternProperties').map(\n      ({ schema, key }, index) => {\n        return callback(schema, key, index)\n      }\n    )\n  }\n\n  reduceProperties = <P, R>(\n    callback?: (\n      buffer: P,\n      schema: Schema<\n        Decorator,\n        Component,\n        DecoratorProps,\n        ComponentProps,\n        Pattern,\n        Display,\n        Validator,\n        Message\n      >,\n      key: SchemaKey,\n      index: number\n    ) => R,\n    predicate?: P\n  ): R => {\n    let results: any = predicate\n    Schema.getOrderProperties(this, 'properties').forEach(\n      ({ schema, key }, index) => {\n        results = callback(results, schema, key, index)\n      }\n    )\n    return results\n  }\n\n  reducePatternProperties = <P, R>(\n    callback?: (\n      buffer: P,\n      schema: Schema<\n        Decorator,\n        Component,\n        DecoratorProps,\n        ComponentProps,\n        Pattern,\n        Display,\n        Validator,\n        Message\n      >,\n      key: SchemaKey,\n      index: number\n    ) => R,\n    predicate?: P\n  ): R => {\n    let results: any = predicate\n    Schema.getOrderProperties(this, 'patternProperties').forEach(\n      ({ schema, key }, index) => {\n        results = callback(results, schema, key, index)\n      }\n    )\n    return results\n  }\n\n  compile = (scope?: any) => {\n    const schema = new Schema({}, this.parent)\n    each(this, (value, key) => {\n      if (isFn(value) && !key.includes('x-')) return\n      if (key === 'parent' || key === 'root') return\n      if (!SchemaNestedMap[key]) {\n        schema[key] = value ? compile(value, scope) : value\n      } else {\n        schema[key] = value ? shallowCompile(value, scope) : value\n      }\n    })\n    return schema\n  }\n\n  fromJSON = (\n    json: ISchema<\n      Decorator,\n      Component,\n      DecoratorProps,\n      ComponentProps,\n      Pattern,\n      Display,\n      Validator,\n      Message\n    >\n  ) => {\n    if (!json) return this\n    if (Schema.isSchemaInstance(json)) return json\n    each(reducePatches(json), (value, key) => {\n      if (isFn(value) && !key.includes('x-')) return\n      if (key === 'properties') {\n        this.setProperties(value)\n      } else if (key === 'patternProperties') {\n        this.setPatternProperties(value)\n      } else if (key === 'additionalProperties') {\n        this.setAdditionalProperties(value)\n      } else if (key === 'items') {\n        this.setItems(value)\n      } else if (key === 'additionalItems') {\n        this.setAdditionalItems(value)\n      } else if (key === '$ref') {\n        this.fromJSON(this.findDefinitions(value))\n      } else {\n        this[key] = value\n      }\n    })\n    return this\n  }\n\n  toJSON = (\n    recursion = true\n  ): ISchema<\n    Decorator,\n    Component,\n    DecoratorProps,\n    ComponentProps,\n    Pattern,\n    Display,\n    Validator,\n    Message\n  > => {\n    const results = {}\n    each(this, (value: any, key) => {\n      if (\n        (isFn(value) && !key.includes('x-')) ||\n        key === 'parent' ||\n        key === 'root'\n      )\n        return\n      if (key === 'properties' || key === 'patternProperties') {\n        if (!recursion) return\n        results[key] = map(value, (item) => item?.toJSON?.())\n      } else if (key === 'additionalProperties' || key === 'additionalItems') {\n        if (!recursion) return\n        results[key] = value?.toJSON?.()\n      } else if (key === 'items') {\n        if (!recursion) return\n        if (Array.isArray(value)) {\n          results[key] = value.map((item) => item?.toJSON?.())\n        } else {\n          results[key] = value?.toJSON?.()\n        }\n      } else {\n        results[key] = value\n      }\n    })\n    return results\n  }\n\n  toFieldProps = (\n    options?: ISchemaTransformerOptions\n  ): IFieldFactoryProps<any, any> => {\n    return transformFieldProps(this, options)\n  }\n\n  static getOrderProperties = (\n    schema: ISchema = {},\n    propertiesName: keyof ISchema = 'properties'\n  ) => {\n    const orderProperties = []\n    const unorderProperties = []\n    for (const key in schema[propertiesName]) {\n      const item = schema[propertiesName][key]\n      const index = item['x-index']\n      if (!isNaN(index)) {\n        orderProperties[index] = { schema: item, key }\n      } else {\n        unorderProperties.push({ schema: item, key })\n      }\n    }\n    return orderProperties.concat(unorderProperties).filter((item) => !!item)\n  }\n\n  static compile = (expression: any, scope?: any) => {\n    return compile(expression, scope)\n  }\n\n  static shallowCompile = (expression: any, scope?: any) => {\n    return shallowCompile(expression, scope)\n  }\n\n  static isSchemaInstance = (value: any): value is Schema => {\n    return instOf(value, Schema)\n  }\n\n  static registerCompiler = registerCompiler\n\n  static registerPatches = registerPatches\n\n  static registerVoidComponents = registerVoidComponents\n\n  static registerTypeDefaultComponents = registerTypeDefaultComponents\n\n  static registerPolyfills = registerPolyfills\n\n  static enablePolyfills = enablePolyfills\n\n  static silent = silent\n}\n", "import * as Vue from 'vue'\n\nvar isVue2 = false\nvar isVue3 = true\nvar Vue2 = undefined\n\nfunction install() {}\n\nexport function set(target, key, val) {\n  if (Array.isArray(target)) {\n    target.length = Math.max(target.length, key)\n    target.splice(key, 1, val)\n    return val\n  }\n  target[key] = val\n  return val\n}\n\nexport function del(target, key) {\n  if (Array.isArray(target)) {\n    target.splice(key, 1)\n    return\n  }\n  delete target[key]\n}\n\nexport * from 'vue'\nexport {\n  Vue,\n  Vue2,\n  isVue2,\n  isVue3,\n  install,\n}\n", "import { InjectionKey, Ref } from 'vue-demi'\nimport { Form, GeneralField } from '@formily/core'\nimport { Schema } from '@formily/json-schema'\nimport { ISchemaFieldVueFactoryOptions } from '../types'\nexport const FormSymbol: InjectionKey<Ref<Form>> = Symbol('form')\nexport const FieldSymbol: InjectionKey<Ref<GeneralField>> = Symbol('field')\nexport const SchemaMarkupSymbol: InjectionKey<Ref<Schema>> =\n  Symbol('schemaMarkup')\nexport const SchemaSymbol: InjectionKey<Ref<Schema>> = Symbol('schema')\nexport const SchemaExpressionScopeSymbol: InjectionKey<\n  Ref<Record<string, any>>\n> = Symbol('schemaExpression')\nexport const SchemaOptionsSymbol: InjectionKey<\n  Ref<ISchemaFieldVueFactoryOptions>\n> = Symbol('schemaOptions')\n", "import { onMounted, watch, Ref, onUnmounted, nextTick } from 'vue-demi'\n\ninterface IRecycleTarget {\n  onMount: () => void\n  onUnmount: () => void\n}\n\nexport const useAttach = <T extends IRecycleTarget>(target: Ref<T>): Ref<T> => {\n  watch(target, (v, old, onInvalidate) => {\n    if (v && v !== old) {\n      old?.onUnmount()\n      nextTick(() => v.onMount())\n      onInvalidate(() => v.onUnmount())\n    }\n  })\n  onMounted(() => {\n    target.value?.onMount()\n  })\n  onUnmounted(() => {\n    target.value?.onUnmount()\n  })\n  return target\n}\n", "import { InjectionKey, provide, Ref, ref } from 'vue-demi'\n\nexport const useInjectionCleaner = (\n  injectionKeys: InjectionKey<Ref<unknown>>[]\n) => {\n  injectionKeys.forEach((key) => provide(key, ref()))\n}\n", "var $placeholder = Symbol();\n\nvar $fakeParent = Symbol();\n\nvar $nextSiblingPatched = Symbol();\n\nvar $childNodesPatched = Symbol();\n\nvar isFrag = function isFrag(node) {\n    return \"frag\" in node;\n};\n\nvar parentNodeDescriptor = {\n    get: function get() {\n        return this[$fakeParent] || this.parentElement;\n    },\n    configurable: true\n};\n\nvar patchParentNode = function patchParentNode(node, fakeParent) {\n    if ($fakeParent in node) {\n        return;\n    }\n    node[$fakeParent] = fakeParent;\n    Object.defineProperty(node, \"parentNode\", parentNodeDescriptor);\n};\n\nvar nextSiblingDescriptor = {\n    get: function get() {\n        var childNodes = this.parentNode.childNodes;\n        var index = childNodes.indexOf(this);\n        if (index > -1) {\n            return childNodes[index + 1] || null;\n        }\n        return null;\n    }\n};\n\nvar patchNextSibling = function patchNextSibling(node) {\n    if ($nextSiblingPatched in node) {\n        return;\n    }\n    node[$nextSiblingPatched] = true;\n    Object.defineProperty(node, \"nextSibling\", nextSiblingDescriptor);\n};\n\nvar getTopFragment = function getTopFragment(node, fromParent) {\n    while (node.parentNode !== fromParent) {\n        var _node = node, parentNode = _node.parentNode;\n        if (parentNode) {\n            node = parentNode;\n        }\n    }\n    return node;\n};\n\nvar getChildNodes;\n\nvar getChildNodesWithFragments = function getChildNodesWithFragments(node) {\n    if (!getChildNodes) {\n        var _childNodesDescriptor = Object.getOwnPropertyDescriptor(Node.prototype, \"childNodes\");\n        getChildNodes = _childNodesDescriptor.get;\n    }\n    var realChildNodes = getChildNodes.apply(node);\n    var childNodes = Array.from(realChildNodes).map((function(childNode) {\n        return getTopFragment(childNode, node);\n    }));\n    return childNodes.filter((function(childNode, index) {\n        return childNode !== childNodes[index - 1];\n    }));\n};\n\nvar childNodesDescriptor = {\n    get: function get() {\n        return this.frag || getChildNodesWithFragments(this);\n    }\n};\n\nvar firstChildDescriptor = {\n    get: function get() {\n        return this.childNodes[0] || null;\n    }\n};\n\nfunction hasChildNodes() {\n    return this.childNodes.length > 0;\n}\n\nvar patchChildNodes = function patchChildNodes(node) {\n    if ($childNodesPatched in node) {\n        return;\n    }\n    node[$childNodesPatched] = true;\n    Object.defineProperties(node, {\n        childNodes: childNodesDescriptor,\n        firstChild: firstChildDescriptor\n    });\n    node.hasChildNodes = hasChildNodes;\n};\n\nfunction before() {\n    var _this$frag$;\n    (_this$frag$ = this.frag[0]).before.apply(_this$frag$, arguments);\n}\n\nfunction remove() {\n    var frag = this.frag;\n    var removed = frag.splice(0, frag.length);\n    removed.forEach((function(node) {\n        node.remove();\n    }));\n}\n\nvar getFragmentLeafNodes = function getFragmentLeafNodes(children) {\n    var _Array$prototype;\n    return (_Array$prototype = Array.prototype).concat.apply(_Array$prototype, children.map((function(childNode) {\n        return isFrag(childNode) ? getFragmentLeafNodes(childNode.frag) : childNode;\n    })));\n};\n\nvar addPlaceholder = function addPlaceholder(node, insertBeforeNode) {\n    var placeholder = node[$placeholder];\n    insertBeforeNode.before(placeholder);\n    patchParentNode(placeholder, node);\n    node.frag.unshift(placeholder);\n};\n\nfunction removeChild(node) {\n    if (isFrag(this)) {\n        var hasChildInFragment = this.frag.indexOf(node);\n        if (hasChildInFragment > -1) {\n            var _this$frag$splice = this.frag.splice(hasChildInFragment, 1), removedNode = _this$frag$splice[0];\n            if (this.frag.length === 0) {\n                addPlaceholder(this, removedNode);\n            }\n            node.remove();\n        }\n    } else {\n        var children = getChildNodesWithFragments(this);\n        var hasChild = children.indexOf(node);\n        if (hasChild > -1) {\n            node.remove();\n        }\n    }\n    return node;\n}\n\nfunction insertBefore(insertNode, insertBeforeNode) {\n    var _this = this;\n    var insertNodes = insertNode.frag || [ insertNode ];\n    if (isFrag(this)) {\n        if (insertNode[$fakeParent] === this && insertNode.parentElement) {\n            return insertNode;\n        }\n        var _frag = this.frag;\n        if (insertBeforeNode) {\n            var index = _frag.indexOf(insertBeforeNode);\n            if (index > -1) {\n                _frag.splice.apply(_frag, [ index, 0 ].concat(insertNodes));\n                insertBeforeNode.before.apply(insertBeforeNode, insertNodes);\n            }\n        } else {\n            var _lastNode = _frag[_frag.length - 1];\n            _frag.push.apply(_frag, insertNodes);\n            _lastNode.after.apply(_lastNode, insertNodes);\n        }\n        removePlaceholder(this);\n    } else if (insertBeforeNode) {\n        if (this.childNodes.includes(insertBeforeNode)) {\n            insertBeforeNode.before.apply(insertBeforeNode, insertNodes);\n        }\n    } else {\n        this.append.apply(this, insertNodes);\n    }\n    insertNodes.forEach((function(node) {\n        patchParentNode(node, _this);\n    }));\n    var lastNode = insertNodes[insertNodes.length - 1];\n    patchNextSibling(lastNode);\n    return insertNode;\n}\n\nfunction appendChild(node) {\n    if (node[$fakeParent] === this && node.parentElement) {\n        return node;\n    }\n    var frag = this.frag;\n    var lastChild = frag[frag.length - 1];\n    lastChild.after(node);\n    patchParentNode(node, this);\n    removePlaceholder(this);\n    frag.push(node);\n    return node;\n}\n\nvar removePlaceholder = function removePlaceholder(node) {\n    var placeholder = node[$placeholder];\n    if (node.frag[0] === placeholder) {\n        node.frag.shift();\n        placeholder.remove();\n    }\n};\n\nvar innerHTMLDescriptor = {\n    set: function set(htmlString) {\n        var _this2 = this;\n        if (this.frag[0] !== this[$placeholder]) {\n            this.frag.slice().forEach((function(child) {\n                return _this2.removeChild(child);\n            }));\n        }\n        if (htmlString) {\n            var domify = document.createElement(\"div\");\n            domify.innerHTML = htmlString;\n            Array.from(domify.childNodes).forEach((function(node) {\n                _this2.appendChild(node);\n            }));\n        }\n    },\n    get: function get() {\n        return \"\";\n    }\n};\n\nvar frag = {\n    inserted: function inserted(element) {\n        var parentNode = element.parentNode, nextSibling = element.nextSibling, previousSibling = element.previousSibling;\n        var childNodes = Array.from(element.childNodes);\n        var placeholder = document.createComment(\"\");\n        if (childNodes.length === 0) {\n            childNodes.push(placeholder);\n        }\n        element.frag = childNodes;\n        element[$placeholder] = placeholder;\n        var fragment = document.createDocumentFragment();\n        fragment.append.apply(fragment, getFragmentLeafNodes(childNodes));\n        element.replaceWith(fragment);\n        childNodes.forEach((function(node) {\n            patchParentNode(node, element);\n            patchNextSibling(node);\n        }));\n        patchChildNodes(element);\n        Object.assign(element, {\n            remove: remove,\n            appendChild: appendChild,\n            insertBefore: insertBefore,\n            removeChild: removeChild,\n            before: before\n        });\n        Object.defineProperty(element, \"innerHTML\", innerHTMLDescriptor);\n        if (parentNode) {\n            Object.assign(parentNode, {\n                removeChild: removeChild,\n                insertBefore: insertBefore\n            });\n            patchParentNode(element, parentNode);\n            patchChildNodes(parentNode);\n        }\n        if (nextSibling) {\n            patchNextSibling(element);\n        }\n        if (previousSibling) {\n            patchNextSibling(previousSibling);\n        }\n    },\n    unbind: function unbind(element) {\n        element.remove();\n    }\n};\n\nvar fragment = {\n    name: \"Fragment\",\n    directives: {\n        frag: frag\n    },\n    render: function render(h) {\n        return h(\"div\", {\n            directives: [ {\n                name: \"frag\"\n            } ]\n        }, this.$slots[\"default\"]);\n    }\n};\n\nexport { fragment as Fragment, frag as default };\n", "import { Fragment as FragmentV2 } from 'vue-frag'\nimport { DefineComponent } from '../types'\nimport { isVue2, defineComponent } from 'vue-demi'\n\nexport const Fragment = '#fragment'\n\nlet FragmentComponent: DefineComponent<{}>\n\nif (isVue2) {\n  FragmentComponent = {\n    name: 'Fragment',\n    ...FragmentV2,\n  } as unknown as DefineComponent<{}>\n} else {\n  /* istanbul ignore next */\n  FragmentComponent = defineComponent({\n    name: 'Fragment',\n    render() {\n      return this.$slots.default()\n    },\n  })\n}\n\nexport { FragmentComponent }\n", "import { each } from '@formily/shared'\n\ntype VNodeData = Record<string, any>\n\nexport const formatVue3VNodeData = (data: VNodeData) => {\n  const newData = {}\n  each(data, (value, key) => {\n    if (key === 'on' || key === 'nativeOn') {\n      if (value) {\n        each(value, (func, name) => {\n          const eventName = `on${\n            key === 'on' ? name[0].toUpperCase() : name[0]\n          }${name.slice(1)}`\n          newData[eventName] = func\n        })\n      }\n    } else if (key === 'attrs' || key === 'props' || key === 'domProps') {\n      Object.assign(newData, value)\n    } else {\n      newData[key] = value\n    }\n  })\n  return newData\n}\n", "import { h, isVue2 } from 'vue-demi'\nimport { Fragment, FragmentComponent } from './fragment'\nimport { formatVue3VNodeData } from '../utils/formatVNodeData'\n\ntype RenderChildren = {\n  [key in string]?: (...args: any[]) => (VNode | string)[]\n}\n\n// TODO: need to compatible with vue2 & vue3\ntype Tag = any\ntype VNodeData = Record<string, any>\ntype VNode = any\ntype VNodeChildren = any\n\nconst compatibleCreateElement = (\n  tag: Tag,\n  data: VNodeData,\n  components: RenderChildren\n): any => {\n  /* istanbul ignore else */\n  if (isVue2) {\n    const hInVue2 = h as (\n      tag: Tag,\n      data?: VNodeData,\n      components?: VNodeChildren\n    ) => VNode\n    const scopedSlots = components // 默认全部作为 scopedSlots 处理\n    const children = []\n\n    /**\n     * scopedSlots 不会映射为slots，所以这里手动映射一遍\n     * 主要为了解决 slots.x 问题\n     */\n    Object.keys(components).forEach((key) => {\n      const func = components[key]\n\n      // 转换为 slots 传递\n      if (typeof func === 'function' && func.length === 0) {\n        /**\n         * func 参数为0的判断不准确，因为composition-api包了一层，导致全部为0\n         * try catch 解决scoped slots 转换参数异常问题\n         * */\n        try {\n          const child = func()\n          children.push(\n            key === 'default'\n              ? child\n              : hInVue2(FragmentComponent, { slot: key }, [child])\n          )\n        } catch (error) {}\n      }\n    })\n    const newData = Object.assign({}, data)\n    if (Object.keys(scopedSlots).length > 0) {\n      if (!newData.scopedSlots) {\n        newData.scopedSlots = scopedSlots\n      } else {\n        newData.scopedSlots = {\n          ...newData.scopedSlots,\n          ...scopedSlots,\n        }\n      }\n    }\n    if (tag === Fragment) {\n      // sometimes we needn't to use Fragment component.\n      if (children.length === 1) {\n        if (!Array.isArray(children[0])) {\n          return children[0]\n        } else if (children[0].length === 1) {\n          if (!Array.isArray(children[0][0])) {\n            return children[0][0]\n          } else if (children[0][0].length === 1) {\n            return children[0][0][0]\n          }\n        }\n      }\n      tag = FragmentComponent\n    }\n    return hInVue2(tag, newData, children)\n  } else {\n    if (tag === Fragment) {\n      tag = FragmentComponent\n    }\n    const hInVue3 = h as (\n      tag: Tag,\n      data?: VNodeData,\n      components?: RenderChildren\n    ) => VNode\n    return hInVue3(tag, formatVue3VNodeData(data), components)\n  }\n}\n\nexport default compatibleCreateElement\n\nexport { compatibleCreateElement as h }\n", "import { provide, defineComponent, toRef } from 'vue-demi'\nimport {\n  FormSymbol,\n  FieldSymbol,\n  SchemaMarkupSymbol,\n  SchemaSymbol,\n  SchemaExpressionScopeSymbol,\n  SchemaOptionsSymbol,\n} from '../shared/context'\nimport { IProviderProps, DefineComponent } from '../types'\nimport { useAttach } from '../hooks/useAttach'\nimport { useInjectionCleaner } from '../hooks/useInjectionCleaner'\nimport h from '../shared/h'\nimport { Fragment } from '../shared/fragment'\n\nexport default defineComponent({\n  name: 'FormProvider',\n  inheritAttrs: false,\n  props: ['form'],\n  setup(props: IProviderProps, { slots }) {\n    const formRef = useAttach(toRef(props, 'form'))\n    provide(FormSymbol, formRef)\n    useInjectionCleaner([\n      FieldSymbol,\n      SchemaMarkupSymbol,\n      SchemaSymbol,\n      SchemaExpressionScopeSymbol,\n      SchemaOptionsSymbol,\n    ])\n\n    return () => h(Fragment, {}, slots)\n  },\n}) as DefineComponent<IProviderProps>\n", "import { inject, Ref, ref } from 'vue-demi'\nimport { Form } from '@formily/core'\nimport { FormSymbol } from '../shared/context'\n\nexport const useForm = (): Ref<Form> => {\n  const form = inject(FormSymbol, ref())\n  return form\n}\n", "import { inject, Ref, ref } from 'vue-demi'\nimport { GeneralField } from '@formily/core'\nimport { FieldSymbol } from '../shared/context'\n\nexport const useField = <T = GeneralField>(): Ref<T> => {\n  return inject(FieldSymbol, ref()) as any\n}\n", "import { onBeforeUnmount } from 'vue-demi'\nimport { Form } from '@formily/core'\nimport { uid } from '@formily/shared'\nimport { useForm } from './useForm'\n\nexport const useFormEffects = (effects?: (form: Form) => void): void => {\n  const formRef = useForm()\n\n  const id = uid()\n  formRef.value.addEffects(id, effects)\n\n  onBeforeUnmount(() => {\n    formRef.value.removeEffects(id)\n  })\n}\n", "import { inject, ref } from 'vue-demi'\nimport { SchemaSymbol } from '../shared/context'\n\nexport const useFieldSchema = () => {\n  return inject(SchemaSymbol, ref())\n}\n", "import { isObjectField, GeneralField, Form, ObjectField } from '@formily/core'\nimport { computed, Ref } from 'vue-demi'\nimport { useField } from './useField'\nimport { useForm } from './useForm'\n\nexport const useParentForm = (): Ref<Form | ObjectField> => {\n  const field = useField()\n  const form = useForm()\n  const findObjectParent = (field: GeneralField) => {\n    if (!field) return form.value\n    if (isObjectField(field)) return field\n    return findObjectParent(field?.parent)\n  }\n  return computed(() => findObjectParent(field.value))\n}\n", "import { defineComponent } from 'vue-demi'\nimport { observer } from '@formily/reactive-vue'\nimport { useForm } from '../hooks'\nimport h from '../shared/h'\n\nexport default observer(\n  defineComponent({\n    name: 'FormConsumer',\n    inheritAttrs: false,\n    setup(props, { slots }) {\n      const formRef = useForm()\n      return () => {\n        // just like <Fragment>\n        return h(\n          'div',\n          { style: { display: 'contents' } },\n          {\n            default: () =>\n              slots.default?.({\n                form: formRef.value,\n              }),\n          }\n        )\n      }\n    },\n  }),\n  {\n    // make sure observables updated <cannot be tracked by tests>\n    scheduler: /* istanbul ignore next */ (update) =>\n      Promise.resolve().then(update),\n  }\n)\n", "import { isVue2, markRaw, defineComponent, getCurrentInstance } from 'vue-demi'\nimport { isFn, isStr, FormPath, each } from '@formily/shared'\nimport { isVoidField, GeneralField } from '@formily/core'\nimport { observer } from '@formily/reactive-vue'\n\nimport { useField } from '../hooks/useField'\nimport h from './h'\n\nimport type {\n  VueComponent,\n  IComponentMapper,\n  IStateMapper,\n  VueComponentProps,\n} from '../types'\n\nexport function mapProps<T extends VueComponent = VueComponent>(\n  ...args: IStateMapper<VueComponentProps<T>>[]\n) {\n  const transform = (input: VueComponentProps<T>, field: GeneralField) =>\n    args.reduce((props, mapper) => {\n      if (isFn(mapper)) {\n        props = Object.assign(props, mapper(props, field))\n      } else {\n        each(mapper, (to, extract) => {\n          const extractValue = FormPath.getIn(field, extract)\n          const targetValue = isStr(to) ? to : extract\n          if (extract === 'value') {\n            if (to !== extract) {\n              delete props['value']\n            }\n          }\n          FormPath.setIn(props, targetValue, extractValue)\n        })\n      }\n      return props\n    }, input)\n\n  return (target: T) => {\n    /* istanbul ignore else */\n    if (isVue2) {\n      return defineComponent<VueComponentProps<T>>({\n        functional: true,\n        name: target.name ? `Connected${target.name}` : `ConnectedComponent`,\n        render(createElement, context) {\n          const fieldRef = useField()\n          const { data } = context\n          const attrs = fieldRef.value\n            ? transform(\n                { ...data.attrs, ...data.props } as VueComponentProps<T>,\n                fieldRef.value\n              )\n            : { ...data.attrs, ...data.props }\n          return createElement(target, { ...data, attrs }, context.children)\n        },\n      })\n    } else {\n      return observer(\n        defineComponent({\n          name: target.name ? `Connected${target.name}` : `ConnectedComponent`,\n          setup(props, { attrs, slots }) {\n            const fieldRef = useField()\n            return () => {\n              const newAttrs = fieldRef.value\n                ? transform(\n                    { ...attrs } as VueComponentProps<T>,\n                    fieldRef.value\n                  )\n                : { ...attrs }\n              return h(\n                target,\n                {\n                  attrs: newAttrs,\n                },\n                slots\n              )\n            }\n          },\n        })\n      )\n    }\n  }\n}\n\nexport function mapReadPretty<T extends VueComponent, C extends VueComponent>(\n  component: C,\n  readPrettyProps?: Record<string, any>\n) {\n  return (target: T) => {\n    return observer(\n      defineComponent({\n        name: target.name ? `Read${target.name}` : `ReadComponent`,\n        setup(props, { attrs, slots, listeners }: Record<string, any>) {\n          const fieldRef = useField()\n          return () => {\n            const field = fieldRef.value\n            return h(\n              field && !isVoidField(field) && field.pattern === 'readPretty'\n                ? component\n                : target,\n              {\n                attrs: {\n                  ...readPrettyProps,\n                  ...attrs,\n                },\n                on: listeners,\n              },\n              slots\n            )\n          }\n        },\n      })\n    )\n  }\n}\n\nexport function connect<T extends VueComponent>(\n  target: T,\n  ...args: IComponentMapper[]\n): T {\n  const Component = args.reduce((target: VueComponent, mapper) => {\n    return mapper(target)\n  }, target)\n  /* istanbul ignore else */\n  if (isVue2) {\n    const functionalComponent = defineComponent({\n      functional: true,\n      name: target.name,\n      render(h, context) {\n        return h(Component, context.data, context.children)\n      },\n    })\n    return markRaw(functionalComponent) as T\n  } else {\n    const functionalComponent = defineComponent({\n      name: target.name,\n      setup(props, { attrs, slots }) {\n        return () => {\n          return h(Component, { props, attrs }, slots)\n        }\n      },\n    })\n    return markRaw(functionalComponent) as T\n  }\n}\n", "import { createForm } from '@formily/core'\nimport { markRaw } from 'vue-demi'\n\nconst createRawForm = (...args: Parameters<typeof createForm>) => {\n  const form = createForm(...args)\n  return markRaw(form)\n}\n\nexport { createRawForm as createForm }\n", "import { inject, provide, Ref, ref, shallowRef, watch } from 'vue-demi'\nimport { GeneralField, isVoidField } from '@formily/core'\nimport { FormPath } from '@formily/shared'\nimport { observer } from '@formily/reactive-vue'\nimport { toJS } from '@formily/reactive'\nimport { SchemaOptionsSymbol, FieldSymbol, h, Fragment } from '../shared'\nimport { useAttach } from '../hooks/useAttach'\nimport { useField, useForm } from '../hooks'\n\nimport type {\n  IReactiveFieldProps,\n  VueComponentProps,\n  DefineComponent,\n} from '../types'\nimport type { VNode } from 'vue'\n\nfunction isVueOptions(options: Record<string, unknown>) {\n  return (\n    typeof options.template === 'string' ||\n    typeof options.render === 'function' ||\n    typeof options.setup === 'function'\n  )\n}\n\nconst wrapFragment = (childNodes: VNode[] | VNode): VNode => {\n  if (!Array.isArray(childNodes)) {\n    return childNodes\n  }\n  if (childNodes.length > 1) {\n    return h(Fragment, {}, { default: () => childNodes })\n  }\n  return childNodes[0]\n}\n\nconst resolveComponent = (render: () => unknown[], extra?: any) => {\n  if (extra === undefined || extra === null) {\n    return render\n  }\n  if (typeof extra === 'string') {\n    return () => [...render(), extra]\n  }\n  // not component\n  if (!isVueOptions(extra) && typeof extra !== 'function') {\n    return render\n  }\n  // for scoped slot\n  if (extra.length > 1 || extra?.render?.length > 1) {\n    return (scopedProps: VueComponentProps<any>) => [\n      ...render(),\n      h(extra, { props: scopedProps }, {}),\n    ]\n  }\n  return () => [...render(), h(extra, {}, {})]\n}\n\nconst mergeSlots = (\n  field: GeneralField,\n  slots: Record<string, any>,\n  content: any\n): Record<string, (...args: any) => any[]> => {\n  const slotNames = Object.keys(slots)\n  if (!slotNames.length) {\n    if (!content) {\n      return {}\n    }\n    if (typeof content === 'string') {\n      return {\n        default: resolveComponent(() => [], content),\n      }\n    }\n  }\n  const patchSlot = (slotName: string) => () =>\n    slots[slotName]?.({ field, form: field.form }) ?? []\n  const patchedSlots: Record<string, (...args: any) => unknown[]> = {}\n  slotNames.forEach((name) => {\n    patchedSlots[name] = patchSlot(name)\n  })\n\n  // for named slots\n  if (content && typeof content === 'object' && !isVueOptions(content)) {\n    Object.keys(content).forEach((key) => {\n      const child = content[key]\n      const slot = patchedSlots[key] ?? (() => [])\n      patchedSlots[key] = resolveComponent(slot, child)\n    })\n    return patchedSlots\n  }\n  // maybe default slot is empty\n  patchedSlots['default'] = resolveComponent(\n    patchedSlots['default'] ?? (() => []),\n    content\n  )\n  return patchedSlots\n}\n\nexport default observer({\n  name: 'ReactiveField',\n  props: {\n    fieldType: {\n      type: String,\n      default: 'Field',\n    },\n    fieldProps: {\n      type: Object,\n      default: () => ({}),\n    },\n  },\n  setup(props: IReactiveFieldProps, { slots }) {\n    const formRef = useForm()\n    const parentRef = useField()\n    const optionsRef = inject(SchemaOptionsSymbol, ref(null))\n    const createField = () =>\n      formRef?.value?.[`create${props.fieldType}`]?.({\n        ...props.fieldProps,\n        basePath: props.fieldProps?.basePath ?? parentRef.value?.address,\n      })\n    const fieldRef = shallowRef(createField()) as Ref<GeneralField>\n    watch(\n      () => props.fieldProps,\n      () => (fieldRef.value = createField())\n    )\n    useAttach(fieldRef)\n    provide(FieldSymbol, fieldRef)\n    return () => {\n      const field = fieldRef.value\n      const options = optionsRef.value\n      if (!field) {\n        return slots.default?.()\n      }\n      if (field.display !== 'visible') {\n        return h('template', {}, {})\n      }\n\n      const mergedSlots = mergeSlots(field, slots, field.content)\n\n      const renderDecorator = (childNodes: any[]) => {\n        if (!field.decoratorType) {\n          return wrapFragment(childNodes)\n        }\n        const finalComponent =\n          FormPath.getIn(options?.components, field.decoratorType as string) ??\n          field.decoratorType\n        const componentAttrs = toJS(field.decorator[1]) || {}\n        const componentData = {\n          attrs: componentAttrs,\n          style: componentAttrs?.style,\n          class: componentAttrs?.class,\n        }\n        delete componentData.attrs.style\n        delete componentData.attrs.class\n\n        return h(finalComponent, componentData, {\n          default: () => childNodes,\n        })\n      }\n\n      const renderComponent = () => {\n        if (!field.componentType) return wrapFragment(mergedSlots?.default?.())\n\n        const component =\n          FormPath.getIn(options?.components, field.componentType as string) ??\n          field.componentType\n\n        const originData = toJS(field.component[1]) || {}\n        const events = {} as Record<string, any>\n        const originChange = originData['@change'] || originData['onChange']\n        const originFocus = originData['@focus'] || originData['onFocus']\n        const originBlur = originData['@blur'] || originData['onBlur']\n\n        // '@xxx' has higher priority\n        Object.keys(originData)\n          .filter((key) => key.startsWith('on'))\n          .forEach((eventKey) => {\n            const eventName = `${eventKey[2].toLowerCase()}${eventKey.slice(3)}`\n            events[eventName] = originData[eventKey]\n          })\n\n        Object.keys(originData)\n          .filter((key) => key.startsWith('@'))\n          .forEach((eventKey) => {\n            events[eventKey.slice(1)] = originData[eventKey]\n            delete originData[eventKey]\n          })\n\n        events.change = (...args: any[]) => {\n          if (!isVoidField(field)) field.onInput(...args)\n          originChange?.(...args)\n        }\n        events.focus = (...args: any[]) => {\n          if (!isVoidField(field)) field.onFocus(...args)\n          originFocus?.(...args)\n        }\n        events.blur = (...args: any[]) => {\n          if (!isVoidField(field)) field.onBlur(...args)\n          originBlur?.(...args)\n        }\n\n        const componentData = {\n          attrs: {\n            disabled: !isVoidField(field)\n              ? field.pattern === 'disabled' || field.pattern === 'readPretty'\n              : undefined,\n            readOnly: !isVoidField(field)\n              ? field.pattern === 'readOnly'\n              : undefined,\n            ...originData,\n            value: !isVoidField(field) ? field.value : undefined,\n          },\n          style: originData?.style,\n          class: originData?.class,\n          on: events,\n        }\n        delete componentData.attrs.style\n        delete componentData.attrs.class\n\n        return h(component, componentData, mergedSlots)\n      }\n\n      return renderDecorator([renderComponent()])\n    }\n  },\n} as unknown as DefineComponent<IReactiveFieldProps>)\n", "import { IFieldProps, VueComponent } from '../types'\nimport { toRaw } from 'vue-demi'\n\nexport const getRawComponent = (\n  props: IFieldProps<VueComponent, VueComponent>\n) => {\n  const { component, decorator } = props\n  let newComponent: typeof props.component\n  let newDecorator: typeof props.component\n  if (Array.isArray(component)) {\n    newComponent = [toRaw(component[0]), component[1]]\n  }\n  if (Array.isArray(decorator)) {\n    newDecorator = [toRaw(decorator[0]), decorator[1]]\n  }\n  return { component: newComponent, decorator: newDecorator }\n}\n", "export const getFieldProps = () => ({\n  name: {},\n  title: {},\n  description: {},\n  value: {},\n  initialValue: {},\n  basePath: {},\n  decorator: Array,\n  component: Array,\n  display: String,\n  pattern: String,\n  required: { type: Boolean, default: undefined },\n  validateFirst: { type: Boolean, default: undefined },\n  hidden: { type: Boolean, default: undefined },\n  visible: { type: Boolean, default: undefined },\n  editable: { type: Boolean, default: undefined },\n  disabled: { type: Boolean, default: undefined },\n  readOnly: { type: Boolean, default: undefined },\n  readPretty: { type: Boolean, default: undefined },\n  dataSource: {},\n  validator: {},\n  reactions: [Array, Function],\n})\n\nexport const getVoidFieldProps = () => ({\n  name: {},\n  title: {},\n  description: {},\n  basePath: {},\n  decorator: Array,\n  component: Array,\n  display: String,\n  pattern: String,\n  hidden: { type: Boolean, default: undefined },\n  visible: { type: Boolean, default: undefined },\n  editable: { type: Boolean, default: undefined },\n  disabled: { type: Boolean, default: undefined },\n  readOnly: { type: Boolean, default: undefined },\n  readPretty: { type: Boolean, default: undefined },\n  reactions: [Array, Function],\n})\n", "import { isVue2, h as _h } from 'vue-demi'\nimport ReactiveField from './ReactiveField'\nimport { getRawComponent } from '../utils/getRawComponent'\n\nimport type { IArrayFieldProps, DefineComponent } from '../types'\nimport { getFieldProps } from '../utils/getFieldProps'\n\nlet ArrayField: DefineComponent<IArrayFieldProps>\n\n/* istanbul ignore else */\nif (isVue2) {\n  ArrayField = {\n    functional: true,\n    name: 'ArrayField',\n    props: getFieldProps(),\n    render(h, context) {\n      const props = context.props as IArrayFieldProps\n      const attrs = context.data.attrs\n      const componentData = {\n        ...context.data,\n        props: {\n          fieldType: 'ArrayField',\n          fieldProps: {\n            ...attrs,\n            ...props,\n            ...getRawComponent(props),\n          },\n        },\n      }\n      return _h(ReactiveField, componentData, context.children)\n    },\n  } as unknown as DefineComponent<IArrayFieldProps>\n} else {\n  ArrayField = {\n    name: 'ArrayField',\n    props: getFieldProps(),\n    setup(props: IArrayFieldProps, context) {\n      return () => {\n        const componentData = {\n          fieldType: 'ArrayField',\n          fieldProps: {\n            ...props,\n            ...getRawComponent(props),\n          },\n        } as Record<string, unknown>\n        return _h(ReactiveField, componentData, context.slots)\n      }\n    },\n  } as unknown as DefineComponent<IArrayFieldProps>\n}\n\nexport default ArrayField\n", "import { isVue2, h as _h } from 'vue-demi'\nimport ReactiveField from './ReactiveField'\nimport { getRawComponent } from '../utils/getRawComponent'\n\nimport type { IObjectFieldProps, DefineComponent } from '../types'\nimport { getFieldProps } from '../utils/getFieldProps'\n\nlet ObjectField: DefineComponent<IObjectFieldProps>\n\n/* istanbul ignore else */\nif (isVue2) {\n  ObjectField = {\n    functional: true,\n    name: 'ObjectField',\n    props: getFieldProps(),\n    render(h, context) {\n      const props = context.props as IObjectFieldProps\n      const attrs = context.data.attrs\n      const componentData = {\n        ...context.data,\n        props: {\n          fieldType: 'ObjectField',\n          fieldProps: {\n            ...attrs,\n            ...props,\n            ...getRawComponent(props),\n          },\n        },\n      }\n      return _h(ReactiveField, componentData, context.children)\n    },\n  } as unknown as DefineComponent<IObjectFieldProps>\n} else {\n  ObjectField = {\n    name: 'ObjectField',\n    props: getFieldProps(),\n    setup(props: IObjectFieldProps, context) {\n      return () => {\n        const componentData = {\n          fieldType: 'ObjectField',\n          fieldProps: {\n            ...props,\n            ...getRawComponent(props),\n          },\n        } as Record<string, unknown>\n        return _h(ReactiveField, componentData, context.slots)\n      }\n    },\n  } as unknown as DefineComponent<IObjectFieldProps>\n}\n\nexport default ObjectField\n", "import { isVue2, h as _h } from 'vue-demi'\nimport ReactiveField from './ReactiveField'\nimport { getRawComponent } from '../utils/getRawComponent'\n\nimport type { IVoidFieldProps, DefineComponent } from '../types'\nimport { getVoidFieldProps } from '../utils/getFieldProps'\n\nlet VoidField: DefineComponent<IVoidFieldProps>\n\n/* istanbul ignore else */\nif (isVue2) {\n  VoidField = {\n    functional: true,\n    name: 'VoidField',\n    props: getVoidFieldProps(),\n    render(h, context) {\n      const props = context.props as IVoidFieldProps\n      const attrs = context.data.attrs\n      const componentData = {\n        ...context.data,\n        props: {\n          fieldType: 'VoidField',\n          fieldProps: {\n            ...attrs,\n            ...props,\n            ...getRawComponent(props),\n          },\n        },\n      }\n      return _h(ReactiveField, componentData, context.children)\n    },\n  } as unknown as DefineComponent<IVoidFieldProps>\n} else {\n  VoidField = {\n    name: 'VoidField',\n    props: getVoidFieldProps(),\n    setup(props: IVoidFieldProps, context) {\n      return () => {\n        const componentData = {\n          fieldType: 'VoidField',\n          fieldProps: {\n            ...props,\n            ...getRawComponent(props),\n          },\n        } as Record<string, unknown>\n        return _h(ReactiveField, componentData, context.slots)\n      }\n    },\n  } as unknown as DefineComponent<IVoidFieldProps>\n}\n\nexport default VoidField\n", "import { isVue2, h as _h } from 'vue-demi'\nimport ReactiveField from './ReactiveField'\nimport { getRawComponent } from '../utils/getRawComponent'\n\nimport type { IFieldProps, DefineComponent } from '../types'\nimport { getFieldProps } from '../utils/getFieldProps'\n\nlet Field: DefineComponent<IFieldProps>\n\n/* istanbul ignore else */\nif (isVue2) {\n  Field = {\n    functional: true,\n    name: 'Field',\n    props: getFieldProps(),\n    render(h, context) {\n      const props = context.props as IFieldProps\n      const attrs = context.data.attrs\n      const componentData = {\n        ...context.data,\n        props: {\n          fieldType: 'Field',\n          fieldProps: {\n            ...attrs,\n            ...props,\n            ...getRawComponent(props),\n          },\n        },\n      }\n      return _h(ReactiveField, componentData, context.children)\n    },\n  } as unknown as DefineComponent<IFieldProps>\n} else {\n  Field = {\n    name: 'Field',\n    props: getFieldProps(),\n    setup(props: IFieldProps, context) {\n      return () => {\n        const componentData = {\n          fieldType: 'Field',\n          fieldProps: {\n            ...props,\n            ...getRawComponent(props),\n          },\n        } as Record<string, unknown>\n        return _h(ReactiveField, componentData, context.slots)\n      }\n    },\n  } as unknown as DefineComponent<IFieldProps>\n}\n\nexport default Field\n", "import { inject, provide, watch, shallowRef, computed, markRaw } from 'vue-demi'\nimport { GeneralField } from '@formily/core'\nimport { isFn, isValid } from '@formily/shared'\nimport { Schema } from '@formily/json-schema'\nimport {\n  SchemaSymbol,\n  SchemaOptionsSymbol,\n  SchemaExpressionScopeSymbol,\n} from '../shared'\nimport { useField } from '../hooks'\nimport ObjectField from './ObjectField'\nimport ArrayField from './ArrayField'\nimport Field from './Field'\nimport VoidField from './VoidField'\nimport { h } from '../shared/h'\nimport { Fragment } from '../shared/fragment'\n\nimport type { IRecursionFieldProps, DefineComponent } from '../types'\n\nconst resolveEmptySlot = (slots: Record<any, (...args: any[]) => any[]>) => {\n  return Object.keys(slots).length ? h(Fragment, {}, slots) : undefined\n}\n\nconst RecursionField = {\n  name: 'RecursionField',\n  inheritAttrs: false,\n  props: {\n    schema: {\n      required: true,\n    },\n    name: [String, Number],\n    basePath: {},\n    onlyRenderProperties: {\n      type: Boolean,\n      default: undefined,\n    },\n    onlyRenderSelf: {\n      type: Boolean,\n      default: undefined,\n    },\n    mapProperties: {},\n    filterProperties: {},\n  },\n  setup(props: IRecursionFieldProps) {\n    const parentRef = useField()\n    const optionsRef = inject(SchemaOptionsSymbol)\n    const scopeRef = inject(SchemaExpressionScopeSymbol)\n    const createSchema = (schemaProp: IRecursionFieldProps['schema']) =>\n      markRaw(new Schema(schemaProp))\n    const fieldSchemaRef = computed(() => createSchema(props.schema))\n\n    const getPropsFromSchema = (schema: Schema) =>\n      schema?.toFieldProps?.({\n        ...optionsRef.value,\n        get scope() {\n          return {\n            ...optionsRef.value.scope,\n            ...scopeRef.value,\n          }\n        },\n      })\n    const fieldPropsRef = shallowRef(getPropsFromSchema(fieldSchemaRef.value))\n\n    watch([fieldSchemaRef, optionsRef], () => {\n      fieldPropsRef.value = getPropsFromSchema(fieldSchemaRef.value)\n    })\n\n    const getBasePath = () => {\n      if (props.onlyRenderProperties) {\n        return props.basePath || parentRef?.value?.address.concat(props.name)\n      }\n      return props.basePath || parentRef?.value?.address\n    }\n\n    provide(SchemaSymbol, fieldSchemaRef)\n\n    return () => {\n      const basePath = getBasePath()\n      const fieldProps = fieldPropsRef.value\n\n      const generateSlotsByProperties = (scoped = false) => {\n        if (props.onlyRenderSelf) return {}\n        const properties = Schema.getOrderProperties(fieldSchemaRef.value)\n        if (!properties.length) return {}\n        const renderMap: Record<string, ((field?: GeneralField) => unknown)[]> =\n          {}\n        const setRender = (\n          key: string,\n          value: (field?: GeneralField) => unknown\n        ) => {\n          if (!renderMap[key]) {\n            renderMap[key] = []\n          }\n          renderMap[key].push(value)\n        }\n        properties.forEach(({ schema: item, key: name }, index) => {\n          let schema: Schema = item\n          if (isFn(props.mapProperties)) {\n            const mapped = props.mapProperties(item, name)\n            if (mapped) {\n              schema = mapped\n            }\n          }\n          if (isFn(props.filterProperties)) {\n            if (props.filterProperties(schema, name) === false) {\n              return null\n            }\n          }\n          setRender(schema['x-slot'] ?? 'default', (field?: GeneralField) =>\n            h(\n              RecursionField,\n              {\n                key: `${index}-${name}`,\n                attrs: {\n                  schema,\n                  name,\n                  basePath: field?.address || basePath,\n                },\n                slot: schema['x-slot'],\n              },\n              {}\n            )\n          )\n        })\n        const slots = {}\n        Object.keys(renderMap).forEach((key) => {\n          const renderFns = renderMap[key]\n          slots[key] = scoped\n            ? ({ field }) => renderFns.map((fn) => fn(field))\n            : () => renderFns.map((fn) => fn())\n        })\n        return slots\n      }\n\n      const render = () => {\n        if (!isValid(props.name))\n          return resolveEmptySlot(generateSlotsByProperties())\n        if (fieldSchemaRef.value.type === 'object') {\n          if (props.onlyRenderProperties)\n            return resolveEmptySlot(generateSlotsByProperties())\n          return h(\n            ObjectField,\n            {\n              attrs: {\n                ...fieldProps,\n                name: props.name,\n                basePath: basePath,\n              },\n            },\n            generateSlotsByProperties(true)\n          )\n        } else if (fieldSchemaRef.value.type === 'array') {\n          return h(\n            ArrayField,\n            {\n              attrs: {\n                ...fieldProps,\n                name: props.name,\n                basePath: basePath,\n              },\n            },\n            {}\n          )\n        } else if (fieldSchemaRef.value.type === 'void') {\n          if (props.onlyRenderProperties)\n            return resolveEmptySlot(generateSlotsByProperties())\n          const slots = generateSlotsByProperties(true)\n          return h(\n            VoidField,\n            {\n              attrs: {\n                ...fieldProps,\n                name: props.name,\n                basePath: basePath,\n              },\n            },\n            slots\n          )\n        }\n\n        return h(\n          Field,\n          {\n            attrs: {\n              ...fieldProps,\n              name: props.name,\n              basePath: basePath,\n            },\n          },\n          {}\n        )\n      }\n\n      if (!fieldSchemaRef.value) return\n\n      return render()\n    }\n  },\n} as unknown as DefineComponent<IRecursionFieldProps>\n\nexport default RecursionField\n", "import { paramCase } from '@formily/shared'\n\nexport const resolveSchemaProps = (props: Record<string, any>) => {\n  const newProps = {}\n  Object.keys(props).forEach((key) => {\n    if (key.indexOf('x') === 0 && key.indexOf('x-') === -1) {\n      newProps[paramCase(key)] = props[key]\n    } else {\n      newProps[key] = props[key]\n    }\n  })\n  return newProps\n}\n", "import { inject, provide, computed, shallowRef, watch } from 'vue-demi'\nimport { ISchema, Schema, SchemaTypes } from '@formily/json-schema'\nimport { RecursionField } from '../components'\nimport {\n  SchemaMarkupSymbol,\n  SchemaExpressionScopeSymbol,\n  SchemaOptionsSymbol,\n} from '../shared'\nimport {\n  ISchemaFieldVueFactoryOptions,\n  SchemaVueComponents,\n  ISchemaFieldProps,\n  ISchemaMarkupFieldProps,\n  ISchemaTypeFieldProps,\n} from '../types'\nimport { resolveSchemaProps } from '../utils/resolveSchemaProps'\nimport { h } from '../shared/h'\nimport { Fragment } from '../shared/fragment'\nimport type { DefineComponent } from '../types'\n\ntype SchemaFieldComponents = {\n  SchemaField: DefineComponent<ISchemaFieldProps>\n  SchemaMarkupField: DefineComponent<ISchemaMarkupFieldProps>\n  SchemaStringField: DefineComponent<ISchemaTypeFieldProps>\n  SchemaObjectField: DefineComponent<ISchemaTypeFieldProps>\n  SchemaArrayField: DefineComponent<ISchemaTypeFieldProps>\n  SchemaBooleanField: DefineComponent<ISchemaTypeFieldProps>\n  SchemaDateField: DefineComponent<ISchemaTypeFieldProps>\n  SchemaDateTimeField: DefineComponent<ISchemaTypeFieldProps>\n  SchemaVoidField: DefineComponent<ISchemaTypeFieldProps>\n  SchemaNumberField: DefineComponent<ISchemaTypeFieldProps>\n}\n\nconst env = {\n  nonameId: 0,\n}\n\nconst getRandomName = () => {\n  return `NO_NAME_FIELD_$${env.nonameId++}`\n}\n\nconst markupProps = {\n  version: String,\n  name: [String, Number],\n  title: {},\n  description: {},\n  default: {},\n  readOnly: {\n    type: Boolean,\n    default: undefined,\n  },\n  writeOnly: {\n    type: Boolean,\n    default: undefined,\n  },\n  enum: {},\n  const: {},\n  multipleOf: Number,\n  maximum: Number,\n  exclusiveMaximum: Number,\n  minimum: Number,\n  exclusiveMinimum: Number,\n  maxLength: Number,\n  minLength: Number,\n  pattern: {},\n  maxItems: Number,\n  minItems: Number,\n  uniqueItems: {\n    type: Boolean,\n    default: undefined,\n  },\n  maxProperties: Number,\n  minProperties: Number,\n  required: {\n    type: [Boolean, Array, String],\n    default: undefined,\n  },\n  format: String,\n  properties: {},\n  items: {},\n  additionalItems: {},\n  patternProperties: {},\n  additionalProperties: {},\n  xIndex: Number,\n  xPattern: {},\n  xDisplay: {},\n  xValidator: {},\n  xDecorator: {},\n  xDecoratorProps: {},\n  xComponent: {},\n  xComponentProps: {},\n  xReactions: {},\n  xContent: {},\n  xVisible: {\n    type: Boolean,\n    default: undefined,\n  },\n  xHidden: {\n    type: Boolean,\n    default: undefined,\n  },\n  xDisabled: {\n    type: Boolean,\n    default: undefined,\n  },\n  xEditable: {\n    type: Boolean,\n    default: undefined,\n  },\n  xReadOnly: {\n    type: Boolean,\n    default: undefined,\n  },\n  xReadPretty: {\n    type: Boolean,\n    default: undefined,\n  },\n}\n\nexport function createSchemaField<\n  Components extends SchemaVueComponents = SchemaVueComponents\n>(options: ISchemaFieldVueFactoryOptions<Components>): SchemaFieldComponents {\n  const SchemaField = {\n    name: 'SchemaField',\n    inheritAttrs: false,\n    props: {\n      schema: {},\n      scope: {},\n      components: {},\n      name: [String, Number],\n      basePath: {},\n      onlyRenderProperties: { type: Boolean, default: undefined },\n      onlyRenderSelf: { type: Boolean, default: undefined },\n      mapProperties: {},\n      filterProperties: {},\n    },\n    setup(props: ISchemaFieldProps, { slots }) {\n      const schemaRef = computed(() =>\n        Schema.isSchemaInstance(props.schema)\n          ? props.schema\n          : new Schema({\n              type: 'object',\n              ...props.schema,\n            })\n      )\n\n      const scopeRef = computed(() => ({\n        ...options.scope,\n        ...props.scope,\n      }))\n\n      const optionsRef = computed(() => ({\n        ...options,\n        components: {\n          ...options.components,\n          ...props.components,\n        },\n      }))\n\n      provide(SchemaMarkupSymbol, schemaRef)\n      provide(SchemaOptionsSymbol, optionsRef)\n      provide(SchemaExpressionScopeSymbol, scopeRef)\n\n      return () => {\n        env.nonameId = 0\n\n        return h(\n          Fragment,\n          {},\n          {\n            default: () => {\n              const children = []\n              if (slots.default) {\n                children.push(\n                  h(\n                    'template',\n                    {},\n                    {\n                      default: () => slots.default(),\n                    }\n                  )\n                )\n              }\n              children.push(\n                h(\n                  RecursionField,\n                  {\n                    attrs: {\n                      ...props,\n                      schema: schemaRef.value,\n                    },\n                  },\n                  {}\n                )\n              )\n              return children\n            },\n          }\n        )\n      }\n    },\n  }\n\n  const MarkupField = {\n    name: 'MarkupField',\n    props: {\n      type: String,\n      ...markupProps,\n    },\n    setup(props: ISchemaMarkupFieldProps, { slots }) {\n      const parentRef = inject(SchemaMarkupSymbol, null)\n      if (!parentRef || !parentRef.value) return () => h('template', {}, {})\n\n      const name = props.name || getRandomName()\n      const appendArraySchema = (schema: ISchema) => {\n        if (parentRef.value.items) {\n          return parentRef.value.addProperty(name, schema)\n        } else {\n          return parentRef.value.setItems(resolveSchemaProps(props))\n        }\n      }\n\n      const schemaRef = shallowRef(null)\n\n      watch(\n        parentRef,\n        () => {\n          if (\n            parentRef.value.type === 'object' ||\n            parentRef.value.type === 'void'\n          ) {\n            schemaRef.value = parentRef.value.addProperty(\n              name,\n              resolveSchemaProps(props)\n            )\n          } else if (parentRef.value.type === 'array') {\n            const schema = appendArraySchema(resolveSchemaProps(props))\n            schemaRef.value = Array.isArray(schema) ? schema[0] : schema\n          }\n        },\n        { immediate: true }\n      )\n      provide(SchemaMarkupSymbol, schemaRef)\n\n      return () => {\n        return h('div', { style: 'display: none;' }, slots)\n      }\n    },\n  }\n\n  const SchemaFieldFactory = (type: SchemaTypes, name: string) => {\n    return {\n      name: name,\n      props: { ...markupProps },\n      setup(props: ISchemaTypeFieldProps, { slots }) {\n        return () =>\n          h(\n            MarkupField,\n            {\n              attrs: {\n                ...props,\n                type: type,\n              },\n            },\n            slots\n          )\n      },\n    }\n  }\n\n  return {\n    SchemaField,\n    SchemaMarkupField: MarkupField,\n    SchemaStringField: SchemaFieldFactory('string', 'SchemaStringField'),\n    SchemaObjectField: SchemaFieldFactory('object', 'SchemaObjectField'),\n    SchemaArrayField: SchemaFieldFactory('array', 'SchemaArrayField'),\n    SchemaBooleanField: SchemaFieldFactory('boolean', 'SchemaBooleanField'),\n    SchemaDateField: SchemaFieldFactory('date', 'SchemaDateField'),\n    SchemaDateTimeField: SchemaFieldFactory('datetime', 'SchemaDatetimeField'),\n    SchemaVoidField: SchemaFieldFactory('void', 'SchemaVoidField'),\n    SchemaNumberField: SchemaFieldFactory('number', 'SchemaNumberField'),\n  } as unknown as SchemaFieldComponents\n}\n", "import { computed, defineComponent, inject, provide, Ref } from 'vue-demi'\nimport { SchemaExpressionScopeSymbol, Fragment, h } from '../shared'\nimport { IExpressionScopeProps } from '../types'\n\nexport const ExpressionScope = defineComponent({\n  name: 'ExpressionScope',\n  props: ['value'],\n  setup(props: IExpressionScopeProps, { slots }) {\n    const scopeRef = inject<Ref>(SchemaExpressionScopeSymbol)\n    const expressionScopeRef = computed(() => ({\n      ...scopeRef.value,\n      ...props.value,\n    }))\n\n    provide(SchemaExpressionScopeSymbol, expressionScopeRef)\n\n    return () => h(Fragment, {}, slots)\n  },\n})\n", "// This file just converts types\nimport * as components from './components'\n\nimport type Vue from 'vue'\nimport type { VueConstructor } from 'vue'\nimport type {\n  IVoidFieldProps,\n  IArrayFieldProps,\n  IObjectFieldProps,\n  IFieldProps,\n  IRecursionFieldProps,\n  IProviderProps,\n  ISchemaMarkupFieldProps,\n  ISchemaFieldProps,\n  ISchemaFieldVueFactoryOptions,\n  ISchemaTypeFieldProps,\n  SchemaVueComponents,\n} from './types'\n\nconst {\n  Field: _Field,\n  ArrayField: _ArrayField,\n  FormConsumer: _FormConsumer,\n  FormProvider: _FormProvider,\n  ObjectField: _ObjectField,\n  RecursionField: _RecursionField,\n  VoidField: _VoidField,\n  createSchemaField: _createSchemaField,\n} = components\n\ntype DefineComponent<Props> = Vue & VueConstructor & Props\n\ntype SchemaFieldComponents = {\n  SchemaField: DefineComponent<Omit<ISchemaFieldProps, 'name' | 'components'>>\n  SchemaMarkupField: DefineComponent<ISchemaMarkupFieldProps>\n  SchemaStringField: DefineComponent<ISchemaTypeFieldProps>\n  SchemaObjectField: DefineComponent<ISchemaTypeFieldProps>\n  SchemaArrayField: DefineComponent<ISchemaTypeFieldProps>\n  SchemaBooleanField: DefineComponent<ISchemaTypeFieldProps>\n  SchemaDateField: DefineComponent<ISchemaTypeFieldProps>\n  SchemaDateTimeField: DefineComponent<ISchemaTypeFieldProps>\n  SchemaVoidField: DefineComponent<ISchemaTypeFieldProps>\n  SchemaNumberField: DefineComponent<ISchemaTypeFieldProps>\n}\n\ntype CreateSchemaField<\n  Components extends SchemaVueComponents = SchemaVueComponents\n> = (\n  options: ISchemaFieldVueFactoryOptions<Components>\n) => SchemaFieldComponents\n\nconst Field = _Field as unknown as DefineComponent<Omit<IFieldProps, 'name'>>\nconst ArrayField = _ArrayField as unknown as DefineComponent<\n  Omit<IArrayFieldProps, 'name'>\n>\nconst ObjectField = _ObjectField as unknown as DefineComponent<\n  Omit<IObjectFieldProps, 'name'>\n>\nconst VoidField = _VoidField as unknown as DefineComponent<\n  Omit<IVoidFieldProps, 'name'>\n>\nconst RecursionField = _RecursionField as unknown as DefineComponent<\n  Omit<IRecursionFieldProps, 'name'>\n>\nconst FormConsumer = _FormConsumer as unknown as DefineComponent<{}>\nconst FormProvider = _FormProvider as unknown as DefineComponent<IProviderProps>\nconst createSchemaField = _createSchemaField as unknown as CreateSchemaField\n\nexport {\n  Field,\n  ArrayField,\n  ObjectField,\n  VoidField,\n  RecursionField,\n  FormConsumer,\n  FormProvider,\n  createSchemaField,\n}\n"],
  "mappings": "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",
  "names": ["traverse", "target", "compile", "source", "__assign", "__assign", "__read", "Schema", "ref", "json", "_a", "item", "isFrag", "patchParentNode", "get", "patchNextSibling", "getTopFragment", "getChildNodesWithFragments", "patchChildNodes", "frag", "getFragmentLeafNodes", "addPlaceholder", "removePlaceholder", "fragment", "h", "__assign", "__assign", "field", "_a", "__assign", "target", "h", "__spreadArray", "__read", "render", "__spreadArray", "__read", "_a", "__assign", "h", "__assign", "h", "__assign", "h", "__assign", "h", "__assign", "__assign", "render", "__assign", "__assign", "ArrayField", "Field", "ObjectField", "RecursionField", "VoidField", "createSchemaField", "Field", "ArrayField", "ObjectField", "VoidField", "RecursionField", "createSchemaField"]
}
